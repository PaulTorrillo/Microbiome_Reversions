import copy
import math

import numpy
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
matplotlib.rcParams['font.family'] = 'Arial'
capacity = 1000000000000000000
mutationmultiplier=10
multiplier=100
bottleneckprob = 0#1 / 10000
mutationrate=0.003*0.5*0.75*0.9*10#*mutationmultiplier #per genome per generation
possiblemutations=500000
numberofruns=1
#Fill Out Your Mutation Numbers
num_ben_muts=0
ben_mut_f=1.1
weak_del_mut_prob=1
s=0.00035
weak_del_f=1-0.35
del_mut_prob=0
del_f=0.99999
strong_del_mut_prob=0
strong_del_f=0.99999
neutral_mut_prob=1-strong_del_mut_prob-del_mut_prob-weak_del_mut_prob #0.225
mut_probs=[[weak_del_mut_prob,del_mut_prob,strong_del_mut_prob,neutral_mut_prob], #1.205
           [del_mut_prob, weak_del_mut_prob, neutral_mut_prob,strong_del_mut_prob],
            [del_mut_prob, weak_del_mut_prob, neutral_mut_prob,strong_del_mut_prob],
            [del_mut_prob,weak_del_mut_prob,neutral_mut_prob,strong_del_mut_prob],
[weak_del_mut_prob,del_mut_prob,strong_del_mut_prob,neutral_mut_prob],
[weak_del_mut_prob,del_mut_prob,strong_del_mut_prob,neutral_mut_prob],]
f_coefs=[ben_mut_f, weak_del_f, del_f, strong_del_f]
bottleneck_f_coefs=[1.25, 1, 1, 1]
transmission_surv=1000
#The class containing the varying "allele"
class allele:
    def __init__(self, size, genotype): #Initialize species class
        self.size=size
        genoholder=genotype.split(":") #Translate from string to array
        self.genotype=[int(numeric_string) for numeric_string in genoholder]

    def update(self, population,availablebens,mutantstoadd,norm, nondeterministic): #Increase population size and add mutants
        if nondeterministic:
            if population>10:
                self.size=numpy.random.poisson((self.get_nf()/norm)*population) #Number of given offspring. Determined by
            else:
                self.size=int((self.get_nf()/norm)*population)
        #Wright Fisher model and realized as Poisson distribution. Only difference from standard Wright-Fisher Model being
        #this distribution is not conditioned on total population being capacity, though the expected total population
        #is capacity
        if self.size>0:
            numberofmutants = numpy.random.binomial(self.size, mutationrate) #Here mutations are determined by bionomial
        else:
            numberofmutants=0
        #distribution
        mutantclasses=numpy.random.multinomial(numberofmutants, numpy.divide(self.genotype, possiblemutations)) #Specific types
        #of those mutants are then determined by the multinomial distribution
        totalnewmuts=[]
        for i in range(len(mutantclasses)):
            mutantnum=mutantclasses[i]
            newbens=0
            if availablebens>self.genotype[0]: #Beneficial mutations are checked for seperately, generated by binomial
                if mutantnum>0:
                    newbens=numpy.random.binomial(mutantnum, (availablebens-self.genotype[0]) / (possiblemutations))
            else:
                newbens=0
            mutantnum=mutantnum-newbens #Remove beneficial mutations from mutant pool
            newsubmuts=numpy.random.multinomial(mutantnum,mut_probs[0]) #Choose other possible types of mutations
            newmuts=[newbens]+newsubmuts.tolist()+[0] #Get set of mutant types and corresponding numbers
            if i<4: #Count any non neutral mutation to neutral mutation as a reversion
                holder=newmuts[4]
                newmuts[5]=holder
                newmuts[4]=0
            totalnewmuts.append(newmuts) #Count total number of new mutants
        self.size=self.size-numberofmutants #Remove mutants from population
        #Need to update appropriate classes
        for i in range(len(totalnewmuts)):
            for j in range(len(totalnewmuts[i])):
                if i!=j:
                    if totalnewmuts[i][j]>0:
                        added=self.genotype[j]+1
                        lost=self.genotype[i]-1
                        copygene=copy.deepcopy(self.genotype)
                        copygene[j]=added
                        copygene[i]=lost
                        if ((i == 3 and (j == 2 or j == 1)) or (i == 2 and j == 1)):
                            copygene[1]=copygene[1]+1
                            copygene[4]=copygene[4]-1
                        mkey=":".join([str(k) for k in copygene])
                        if mkey in mutantstoadd:
                            mutantstoadd[mkey]=mutantstoadd[mkey]+totalnewmuts[i][j]
                        else:
                            mutantstoadd[mkey]=totalnewmuts[i][j]
        return mutantstoadd
    def get_nf(self): #Returns population multiplied by selective advantage
        toproduct=1
        for i in range(4):
            toproduct=toproduct*(f_coefs[i]**self.genotype[i]) #Calulate selective advantage
        return toproduct*self.size
    def get_f(self):
        toproduct=1
        for i in range(4):
            toproduct=toproduct*(f_coefs[i]**self.genotype[i]) #Calulate selective advantage
        return toproduct
    def increase_size(self,value): #Increasing size (for adding mutants)
        self.size=self.size+value
    def get_size(self): #Return size
        return self.size
    def get_reversions(self): #Return number of reversions multiplied by population (reversion mass?)
        return self.size*self.genotype[1]
    def get_mutations(self):
        tosum=0
        for i in range(1,4):
            tosum=tosum+self.genotype[i] #Calulate selective advantage
        return tosum*self.size
    def get_f_bottleneck(self):
        toproduct = 1
        for i in range(4):
            toproduct = toproduct * (bottleneck_f_coefs[i] ** self.genotype[i])  # Caclulate selective advantage
        return toproduct
    def bottlenecked(self, value):
        self.size=value
        #self.genotype[4]=self.genotype[4]+self.genotype[0]
        #self.genotype[0]=0
        newgeno = str(self.genotype[0])
        for i in range(len(self.genotype) - 1):
            newgeno = newgeno + ':' + str(self.genotype[i + 1])
        return (newgeno, self.size)
    def end_phage(self):
        self.genotype[2] = self.genotype[2] + self.genotype[0]
        self.genotype[0] = 0
        newgeno=str(self.genotype[0])
        for i in range(len(self.genotype)-1):
            newgeno=newgeno+':'+str(self.genotype[i+1])
        return (newgeno,self.size)
if __name__ == '__main__':
    reversionsz = []
    maxesz = []
    avgfz = []
    maxfz = []
    maxesfz = []
    mutationsz = []
    for zed in range(1):
        reversions = [None]*numberofruns
        maxes=[None]*numberofruns
        avgf=[None]*numberofruns
        maxf = [None] * numberofruns
        maxesf=[None]*numberofruns
        mutations=[None]*numberofruns
        #We just simulate every 10 generations to save on time here. One could honestly probably do this for the other
        # simulations as well but this makes the most sense since its meant to simulate only neutral evolution except at transmission
        for u in range(numberofruns):
            print(numberofruns*zed+u)
            numbergens=10000
            capacity = 1000000000000000000
            bottleneckprob =0#1/10000
            currentpopsize=capacity
            norm=0
            currentclasses={}
            currentclasses["0:0:0:0:" + str(possiblemutations) + ":0"]=allele(capacity, "0:0:0:0:" + str(possiblemutations) + ":0") #Set up initial class
            availablebens=0 #Provide initial number of beneficial mutations
            reversions[u]=numpy.zeros(numbergens)
            transmissionbottleneck=False
            selectivebottleneck=False
            mutations[u]=numpy.zeros(numbergens)
            maxes[u]=[]
            maxesf[u] = []
            avgf[u]=numpy.zeros(numbergens)
            cumulativebeneficialmuts=0
            for k in range(numbergens):
                if k%(multiplier*10)==0:
                    nondeterministic=True
                else:
                    nondeterministic=False
                currentpopsize=min(math.ceil(currentpopsize+(currentpopsize*(1-(currentpopsize/capacity)))),capacity) #Use logistic growth
                #model with sharp cut off at capacity
                norm = 0 #Need to check how one allele will be compared to all other alleles
                for x in currentclasses:
                    norm=norm+currentclasses[x].get_nf()
                mutantstoadd={}
                transmissionmuts=1
                for x in currentclasses:
                    modifier=1
                    if selectivebottleneck:
                        modifier=(1/1.99)+((1.99*currentclasses[x].genotype[0])/19.9)
                    mutantstoadd=currentclasses[x].update(modifier*currentpopsize,availablebens,mutantstoadd,norm, nondeterministic) #With projected
                    #population we can launch our update
                #Add in mutants
                for x in mutantstoadd:
                    if x in currentclasses:
                        currentclasses[x].increase_size(mutantstoadd[x])
                    else:
                        currentclasses[x]=allele(mutantstoadd[x], x)
                marked=[]
                currentmax=0
                currentmaxf=0
                currentmaxfpop=0
                maxspec=None
                populationsize=0
                spec_size_list=[]
                spec_name_list=[]
                for x in currentclasses:
                    spec_size=currentclasses[x].get_size()
                    spec_f=currentclasses[x].get_f()
                    populationsize=populationsize+spec_size
                    if spec_size>currentmax:
                        currentmax=spec_size
                        maxspec=x
                    if spec_f>=currentmaxf:
                        if spec_size>currentmaxfpop or spec_f!=currentmaxf:
                            currentmaxf=spec_f
                            currentmaxfpop=spec_size
                    if spec_size<1:
                        marked.append(x)
                    else:
                        spec_size_list.append(spec_size)
                        spec_name_list.append(x)
                    avgf[u][k]=avgf[u][k]+currentclasses[x].get_nf()
                    reversions[u][k]=reversions[u][k]+currentclasses[x].get_reversions()
                    mutations[u][k]=mutations[u][k]+currentclasses[x].get_mutations()
                for x in marked:
                    del currentclasses[x]
                print(k)
                print(len(currentclasses))
                #print(populationsize)
                print(maxspec)
                print(currentmaxf)
                print(currentmaxfpop/populationsize)
                print("Population "+str(populationsize))
                reversions[u][k]=reversions[u][k]/populationsize
                print(reversions[u][k])
                avgf[u][k]=avgf[u][k]/populationsize
                maxes[u].append(currentmax)
                maxesf[u].append(currentmaxfpop/populationsize)
                mutations[u][k]=mutations[u][k]/populationsize#+cumulativebeneficialmuts
                print("mutations")
                print(mutations[u][k])
                if transmissionbottleneck:
                    survivors=numpy.random.multinomial(transmission_surv,numpy.divide(spec_size_list,populationsize))
                    recreate=[]
                    newcurrentclasses={}
                    for z in range(len(survivors)):
                        recreate.append(currentclasses[spec_name_list[z]].bottlenecked(survivors[z]))
                    for g in recreate:
                        if g[0] in newcurrentclasses:
                            newcurrentclasses[g[0]].increase_size(g[1])
                        else:
                            newcurrentclasses[g[0]] = allele(g[1], g[0])
                    currentclasses = newcurrentclasses
                    populationsize=transmission_surv
                    transmissionbottleneck=False
                #if k>0 and k%10000==0 and k<40001: #Release new beneficial mutations
                if numpy.random.uniform(0,1)<bottleneckprob:
                    #availablebens=numpy.random.binomial(80,1/16)
                    #cumulativebeneficialmuts=cumulativebeneficialmuts+num_ben_muts
                    transmissionbottleneck = True
                    selectivebottleneck=False
                #if numpy.random.uniform(0,1)<((1/(840*3))):
                  #  availablebens=availablebens+3
                currentpopsize=populationsize
        reversionsz.append(numpy.mean(reversions,axis=0))
        maxesz.append(numpy.mean(maxes,axis=0))
        avgfz.append(numpy.mean(avgf,axis=0))
      #  maxfz.append(numpy.mean(maxf,axis=0))
        maxesfz.append(numpy.mean(maxesf,axis=0))
        mutationsz.append(numpy.mean(mutations,axis=0))
    num_points = numbergens  # 5 years worth of data
    x_days = numpy.arange(num_points)*10  # days
    y_data = maxesf[0]

    x_years = x_days / 365

    # Create the figure and the axes
    fig, ax1 = plt.subplots()

    # Plot the data on the first axis
    #numpy.savetxt('edges2.txt',y_data,)
    #ax1.plot(x_days, y_data,label='continous selection sim')
    #ydata2=numpy.loadtxt('edges.txt')
    ax1.plot(x_days,y_data,label='transmission selection sim')
    ax1.plot(x_days, numpy.exp(-(0.0010125 * 10000 * (1 - numpy.exp(-0.35 * 0.0001 * x_days)) / 0.35)), '--',
             label='theory')
    matplotlib.pyplot.legend(fontsize=20)
    ax1.set_xlabel('bacterial generations', size=22)
    ax1.set_yscale('log')
    ax1.set_ylabel('frequency of wild type (mutation free) class',size=22)
    plt.tick_params(length=18, width=1, which='major', direction='inout')
    plt.tick_params(length=10, width=1, which='minor', direction='inout')
    plt.xticks(size=20)
    plt.yticks(size=20)
    # Create a second axis for years
   # ax1.legend()
    ax2 = ax1.twiny()

    # Set the limits of the second axis in years
    ax2.set_xlim(ax1.get_xlim())
    ax2.set_xlabel('years',size=22)


    # Define a function to format the ticks on the second axis
    def years_formatter(x, pos):
        years = int(x/365)
        return f'{years}'


    # Set the tick formatter for the second axis
    ax2.xaxis.set_major_formatter(FuncFormatter(years_formatter))

    # Show the plot
   # matplotlib.pyplot.yscale('log')
    plt.tick_params(length=18, width=1, which='major', direction='inout')
    plt.tick_params(length=10, width=1, which='minor', direction='inout')
    plt.xticks(size=20)
    plt.yticks(size=20)
    matplotlib.pyplot.show()
